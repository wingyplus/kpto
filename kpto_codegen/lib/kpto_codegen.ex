defmodule KptoCodegen do
  @moduledoc """
  Documentation for `KptoCodegen`.
  """

  @do_not_edit "# This code generated by `mix kpt.codegen`. PLEASE DO NOT EDIT."

  def generate(%{"definitions" => definitions}, namespace) do
    for {namespace_type, spec} <- definitions do
      module = to_module_name(namespace_type, namespace)
      dir = namespace |> String.downcase() |> String.replace(".", "_")

      {dir, "#{Macro.underscore(extract_type(namespace_type))}.ex",
       to_module(module, namespace, spec)}
    end
  end

  defp to_module(module, _namespace, %{"type" => "string", "title" => doc}) do
    """
    #{@do_not_edit}
    defmodule #{module} do
      @moduledoc \"\"\"
    #{doc} 
    \"\"\"

      @type t() :: String.t()
    end
    """
  end

  defp to_module(
         module,
         namespace,
         %{
           "type" => "object",
           "properties" => properties
         } = spec
       ) do
    doc =
      case spec do
        %{"title" => doc} -> doc
        %{"description" => doc} -> doc
        _ -> ""
      end

    [
      @do_not_edit,
      ?\n,
      "defmodule #{module} do",
      ?\n,
      moduledoc(doc),
      ?\n,
      typespec(properties, namespace),
      ?\n,
      define_struct(properties),
      ?\n,
      reflection(properties, namespace),
      ?\n,
      "end",
      ?\n
    ]
    |> IO.iodata_to_binary()
  end

  defp reflection(properties, namespace) do
    [
      "def __reflection__(:mapper) do",
      ?\n,
      ?[,
      for {name, spec} <- properties do
        [
          Macro.underscore(name),
          ?:,
          ~c" ",
          ?{,
          ?",
          name,
          ?",
          ?,,
          reflect_type(spec, namespace),
          ?},
          ?,
        ]
      end,
      ?],
      ?\n,
      "end"
    ]
  end

  defp reflect_type(%{"type" => "object", "properties" => properties}, namespace) do
    fun = fn {name, spec} ->
      [
        Macro.underscore(name),
        ?:,
        ~c" ",
        ?{,
        ?",
        name,
        ?",
        ?,,
        reflect_type(spec, namespace),
        ?},
        ?,
      ]
    end

    [?{, ":map", ?,, Enum.map(properties, fun), ?}]
  end

  defp reflect_type(%{"type" => "object"}, _), do: ":map"
  defp reflect_type(%{"type" => "string"}, _), do: ":string"

  defp reflect_type(%{"type" => "array", "items" => spec}, namespace),
    do: [?{, ":array", ?,, reflect_type(spec, namespace), ?}]

  defp reflect_type(%{"$ref" => <<"#/definitions/", type::binary>>}, namespace),
    do: to_module_name(type, namespace)

  defp reflect_type(_, _), do: ":any"

  defp define_struct(properties) do
    [
      "defstruct [",
      for {name, _} <- properties do
        key =
          name
          |> Macro.underscore()
          |> atom()

        [key, ?,]
      end,
      ?]
    ]
  end

  defp typespec(properties, namespace) do
    [
      "@type t() :: %__MODULE__{",
      ?\n,
      for {name, spec} <- properties do
        name = Macro.underscore(name)
        "#{name}: #{format_type(spec, namespace)},"
      end,
      ?\n,
      "}"
    ]
  end

  defp moduledoc(doc) do
    """
    @moduledoc \"\"\"
    #{doc}
    \"\"\"
    """
  end

  defp atom(name), do: [~c":", name]

  defp format_type(%{"type" => "array", "items" => spec}, namespace),
    do: [?[, format_type(spec, namespace), ?]]

  defp format_type(%{"type" => "string", "enum" => values}, _) do
    Enum.map_join(values, " | ", &":#{&1}")
  end

  defp format_type(%{"type" => "string"}, _), do: "String.t()"

  defp format_type(%{"$ref" => <<"#/definitions/", type::binary>>}, namespace),
    do: [to_module_name(type, namespace), ".t()"]

  defp format_type(%{"type" => "object", "properties" => properties}, namespace) do
    [
      "%{",
      ?\n,
      for {name, spec} <- properties do
        name = Macro.underscore(name)
        "#{name}: #{format_type(spec, namespace)},"
      end,
      ?\n,
      "}"
    ]
  end

  # Object with no properties, assume it's a map with dynamic key.
  defp format_type(%{"type" => "object"}, _) do
    "map()"
  end

  defp format_type(_, _) do
    "String.t() | integer() | boolean() | list() | map()"
  end

  defp extract_type(namespace_type) do
    case String.split(namespace_type, ".") do
      [_dev, _kpt, _v1, type] -> type
      [type] -> type
    end
  end

  defp to_module_name(namespace_type, namespace) do
    name = namespace_type |> extract_type() |> Macro.camelize()

    (String.split(namespace) ++ [name])
    |> Module.concat()
    |> to_string()
    |> String.trim_leading("Elixir.")
  end
end
