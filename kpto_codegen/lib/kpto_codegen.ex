defmodule KptoCodegen do
  @moduledoc """
  Documentation for `KptoCodegen`.
  """

  @do_not_edit "# This code generated by `mix kpt.codegen`. PLEASE DO NOT EDIT."

  def generate(%{"definitions" => definitions}, namespace) do
    for {namespace_type, spec} <- definitions do
      module = to_module_name(namespace_type, namespace)
      dir = namespace |> String.downcase() |> String.replace(".", "_")

      {dir, "#{Macro.underscore(extract_type(namespace_type))}.ex",
       to_module(module, namespace, spec)}
    end
  end

  defp to_module(module, _namespace, %{"type" => "string", "title" => doc}) do
    """
    #{@do_not_edit}
    defmodule #{module} do
      @moduledoc \"\"\"
    #{doc} 
    \"\"\"

      @type t() :: String.t()
    end
    """
  end

  defp to_module(
         module,
         namespace,
         %{
           "type" => "object",
           "properties" => properties
         } = spec
       ) do
    doc =
      case spec do
        %{"title" => doc} -> doc
        %{"description" => doc} -> doc
        _ -> ""
      end

    [
      @do_not_edit,
      ?\n,
      """
      defmodule #{module} do
        @moduledoc \"\"\"
      #{doc}
      \"\"\"
      """,
      ?\n,
      "@type t() :: %__MODULE__{",
      ?\n,
      for {name, spec} <- properties do
        name = Macro.underscore(name)
        "#{name}: #{format_type(spec, namespace)},"
      end,
      ?\n,
      "}",
      ?\n,
      "defstruct [",
      for {name, _} <- properties do
        key =
          name
          |> Macro.underscore()
          |> atom()

        [key, ?,]
      end,
      "]",
      ?\n,
      "end"
    ]
    |> IO.iodata_to_binary()
  end

  defp atom(name), do: [~c":", name]

  defp format_type(%{"type" => "array", "items" => spec}, namespace),
    do: [?[, format_type(spec, namespace), ?]]

  defp format_type(%{"type" => "string", "enum" => values}, _) do
    Enum.map_join(values, " | ", &":#{&1}")
  end

  defp format_type(%{"type" => "string"}, _), do: "String.t()"

  defp format_type(%{"$ref" => <<"#/definitions/", type::binary>>}, namespace),
    do: [to_module_name(type, namespace), ".t()"]

  defp format_type(%{"type" => "object", "properties" => properties}, namespace) do
    [
      "%{",
      ?\n,
      for {name, spec} <- properties do
        name = Macro.underscore(name)
        "#{name}: #{format_type(spec, namespace)},"
      end,
      ?\n,
      "}"
    ]
  end

  # Object with no properties, assume it's a map with dynamic key.
  defp format_type(%{"type" => "object"}, _) do
    "map()"
  end

  defp format_type(_, _) do
    "String.t() | integer() | boolean() | list() | map()"
  end

  defp extract_type(namespace_type) do
    case String.split(namespace_type, ".") do
      [_dev, _kpt, _v1, type] -> type
      [type] -> type
    end
  end

  defp to_module_name(namespace_type, namespace) do
    name = namespace_type |> extract_type() |> Macro.camelize()

    (String.split(namespace) ++ [name])
    |> Module.concat()
    |> to_string()
    |> String.trim_leading("Elixir.")
  end
end
